Backend:
    Backend is the part of the application that is not visible to the user. It is the part of the application
    that is responsible for storing and retrieving data from the database. It is also responsible for
    processing the data and sending it to the frontend.

    Backend framework:
        Backend framework is a software framework that is designed to support the development of web applications
        including web services, web resources, and web APIs. Backend frameworks are usually written in
        high-level programming languages such as Java, Python, PHP, and Ruby.

        Express Js:
            Express Js is a web application framework for Node Js. It is used to build web applications and APIs.
            It is a minimal and flexible Node Js web application framework that provides a robust set of features
            for web and mobile applications. It is used to build single-page, multi-page, and hybrid web applications.
            Mainly its work is to handle the HTTP requests from frontend and send the response from the backend.
            
            REST Api? :
                REST stands for Representational State Transfer. It is an architectural style for designing
                networked applications. It is a set of constraints that developers follow while creating
                web services.

            HTTP Methods:
                HTTP methods are used to perform different operations on the resources. There are many types of
                HTTP methods:
                    - GET: It is used to retrieve/getting the data from the server. (read)
                    - POST: It is used to send the data to the server. (create)
                    - PUT: It is used to update the data on the server. (update)
                    - DELETE: It is used to delete the data from the server. (delete)
                    - PATCH: It is used to update the data partially on the server. (update)
                    - HEAD: It is used to retrieve the metadata from the server. (read)
                    - OPTIONS: It is used to retrieve the supported HTTP methods from the server. (read)

            How to start Express js:
                - Initialize the project by using " npm init -y " command.
                - Install express js by using " npm install express " command.
                - Create a file named "index.js" and write the following code in it.

                   " const express = require('express');
                    const PORT = system.env.PORT || 3000; // PORT is the port number on which the server will run.
                    const app = express();

                    app.listen(3000, () => {
                        console.log(`Server is running on port ${PORT}`);
                    }); "

                - Run the server by using " node index.js " command.
                - Open the browser and type " localhost:3000 " in the address bar.
                - app has many methods like get, post, put, delete, patch, head, options, etc.
                    - app.get() method is used to handle the GET request.
                    - app.post() method is used to handle the POST request.
                    - app.put() method is used to handle the PUT request.
                    - app.delete() method is used to handle the DELETE request.
                    - app.patch() method is used to handle the PATCH request. etc
                    These methods take two parameters:
                        - First parameter is the route or the path.
                        - Second parameter is the callback function which takes two parameters:
                            1. req: It is the request object. It contains the information about the request.
                                - req.body: It contains the data sent by the client.
                                - req.params: It contains the parameters sent by the client.
                                - req.query: It contains the query string sent by the client.
                                - req.headers: It contains the headers sent by the client.
                                - req.cookies: It contains the cookies sent by the client.
                                - req.ip: It contains the IP address of the client.
                                - req.method: It contains the HTTP method used by the client.
                                - req.path: It contains the path of the request.
                                - req.protocol: It contains the protocol used by the client.
                                - req.subdomains: It contains the subdomains of the client.
                                - req.xhr: It contains the boolean value that indicates whether the request is
                                    an AJAX request or not.
                            2. res: It is the response object. It is used to send the response to the client.
                                - res.send(): It is used to send the response to the client.
                                - res.json(): It is used to send the JSON response to the client.
                                - res.status(): It is used to set the status code of the response.
                                - res.cookie(): It is used to set the cookie in the response.
                                - res.redirect(): It is used to redirect the client to another page.
                                - res.download(): It is used to download the file to the client.
                                - res.sendFile(): It is used to send the file to the client.
                                - res.render(): It is used to render the HTML file to the client.
                                - res.set(): It is used to set the header in the response.
                                - res.type(): It is used to set the content type of the response.
                                - res.append(): It is used to append the value to the header in the response.
                                - res.end(): It is used to end the response.
                                - res.format(): It is used to send the response in different formats.
                                - res.get(): It is used to get the value of the header in the response.
                                - res.links(): It is used to set the links in the response.
                                - res.location(): It is used to set the location in the response.
                                - res.vary(): It is used to set the vary in the response.
                                - res.write(): It is used to write the data in the response.
                                - res.writeContinue(): It is used to write the continue in the response.
                                - res.writeHead(): It is used to write the header in the response.
                                - res.writeProcessing(): It is used to write the processing in the response.


            Environment Variables:
                Environment variables are the variables that are used to store the information about the
                environment. It is used to store the sensitive information like database credentials, API keys,
                etc. It is used to store the information that is different for different environments like
                development, testing, production, etc. It is used to store the information that is different
                for different users. It is used to store the information that is different for different
                machines. It is used to store the information that is different for different versions of
                the application.
                Some of these are:
                    - PORT: It is the port number on which the server will run.
                    - NODE_ENV: It is the environment in which the server will run.
                    - DATABASE_URL: It is the URL of the database.
                    - DATABASE_USERNAME: It is the username of the database.
                    - DATABASE_PASSWORD: It is the password of the database.
                    - DATABASE_NAME: It is the name of the database.
                    - DATABASE_HOST: It is the host of the database.
                    - DATABASE_PORT: It is the port number of the database.
                How to use environment variables:
                    - Create a file named ".env" and write the following code in it.

                        " PORT=3000
                        NODE_ENV=development
                        DATABASE_URL=postgres://localhost:5432
                        DATABASE_USERNAME=postgres
                        DATABASE_PASSWORD=postgres
                        DATABASE_NAME=postgres
                        DATABASE_HOST=localhost
                        DATABASE_PORT=5432 "

                    - Install dotenv by using " npm install dotenv " command.
                        Dotenv is a zero-dependency module that loads environment variables from a .env file
                        into process.env. Storing configuration in the environment separate from code is based
                        on The Twelve-Factor App methodology.
                    - Require dotenv in the index.js file.
                        " require('dotenv').config(); " or " require('dotenv/config'); "
                    - Now you can access the environment variables by using " process.env.ENVIRONMENT_VARIABLE_NAME ".
                        For example, you can access the PORT by using " process.env.PORT ".
                    - Environment:
                        Environment is the place where the application is running. It can be development, production,
                        testing or staging. We can set the environment by using the NODE_ENV environment variable. Syntax is:
                            " NODE_ENV=development "
                        We can access the environment by using " process.env.NODE_ENV ".
                        We can also set the environment by using the app.set() method. Syntax is:
                            " app.set('env', 'development'); "
                        We can access the environment by using " app.get('env') ".
                        We should use the environment to set the configuration of the application. and use the 
                        middleware for specific environments. For example, we can use the morgan middleware for
                        development environment and we can use the helmet middleware for production environment.
                        as:
                            " if (app.get('env') === 'development') {
                                app.use(morgan('tiny'));
                                console.log('Morgan enabled...');
                            } 
                            if (app.get('env') === 'production') {
                                app.use(helmet());
                                console.log('Helmet enabled...');
                            } "
                    - Configuration:
                        It is used to set the configuration of the application. Configuration is of two types:
                            1. Application Configuration.
                            2. Environment Configuration.
                        We use this packages for configuration:
                            - config: It is used to set the configuration of the application.
                                We should make a folder named 'config' and make a file named 'default.json' in it. Syntax is:
                                    " {
                                        "name": "Express Application"
                                    } "
                                also a file named 'development.json' in it. Syntax is:
                                    " {
                                        "name": "Express Application Development"
                                    } "
                            - dotenv: It is used to set the environment configuration.
                            - rc : It is used to set the configuration of the application.


            Route Parameters and Query String:
                Parameters:
                    Route parameters are the parameters that are used to send the data to the server. Syntax is:
                        " /:parameter_name "
                    For example, if you want to send the id of the user to the server, then the syntax is:
                        " /:id "
                    You can access the route parameters by using " req.params.parameter_name ".
                    For example, you can access the id by using " req.params.id ".
                    You can also use multiple route parameters. Syntax is:
                        " /:parameter_name1/:parameter_name2 "
                        " app.get('/users/:id', (req, res) => {
                            res.send(req.params.id);
                        }); "
                Query String:
                    Query string is the part of the URL that comes after the question mark (?). It is used to send
                    the data to the server. Syntax is:
                        " ?parameter_name1=parameter_value1&parameter_name2=parameter_value2 "
                    For example, if you want to send the id and name of the user to the server, then the syntax is:
                        " ?id=1&name=John "
                    You can access the query string by using " req.query.parameter_name ".
                    For example, you can access the id by using " req.query.id ".
                    You can also use multiple query strings. Syntax is:
                        " ?parameter_name1=parameter_value1&parameter_name2=parameter_value2 "
                        " app.get('/users', (req, res) => {
                            res.send(req.query.id);
                        }); "


            Middleware :
                Middleware is a function that has access to the request object (req), the response object (res),
                and the next middleware function in the application’s request-response cycle. The next middleware
                function is commonly denoted by a variable named next. This function are run before the request is
                made. Middleware functions can perform the following tasks:
                    - Execute any code.
                    - Make changes to the request and the response objects.
                    - End the request-response cycle.
                    - Call the next middleware function in the stack.
                Middleware are of three types:
                    1. Builtin middleware:
                        This middleware are built-in to Express. They are:
                            - express.json(): It is used to parse the JSON data in the request body.
                            - express.urlencoded(): It is used to parse the URL-encoded data in the request body.
                            we should pass the extended option to true to parse the nested objects. as:
                                " app.use(express.urlencoded({ extended: true })); "
                            - express.raw(): It is used to parse the raw data in the request body.
                            - express.text(): It is used to parse the text data in the request body.
                            - express.static(): It is used to serve the static files.
                            - express.Router(): It is used to create the router.
                    2. Custom middleware:
                        This middleware are created by the developer to perform the specific task. Syntax is:
                            " app.use((req, res, next) => {
                                // Code

                                next();
                            }); "
                        next is a function that is used to call the next middleware in the stack. If you don't call
                        next(), then the request will be stuck in the middleware and the response will not be sent.
                    3. Third-party middleware:
                        This middleware are created by the third-party to perform the specific task. Syntax is:
                            " app.use(middleware); "
                        For example, if you want to use the helmet middleware, which is used to set the security, its syntax is:
                            " npm install helmet "
                            " app.use(helmet()); "
                        Some of other useful middleware are:
                            - morgan: It is used to log the request.
                            - compression: It is used to compress the response.
                            - helmet: It is used to set the security.
                            - cors: It is used to enable the CORS.
                            - body-parser: It is used to parse the request body.
                            - cookie-parser: It is used to parse the cookies.
                            - debug: It is used to debug the application.
                            - errorhandler: It is used to handle the errors.
                            - method-override: It is used to override the HTTP methods.
                            - serve-favicon: It is used to serve the favicon.
                            - serve-static: It is used to serve the static files.
                            - winston: It is used to log the request.
                            - express-validator: It is used to validate the request body.
                            - express-jwt: It is used to validate the JWT.
                            - express-session: It is used to manage the session.
                            - express-fileupload: It is used to upload the files.
                            - express-flash: It is used to flash the messages.
                            - express-mongo-sanitize: It is used to sanitize the data.
            
            Template Engines:
                Template Engines are used to generate the HTML pages dynamically. It is used to generate the HTML
                pages from the server. We have the following template engines:
                    - Pug
                    - Mustache
                    - EJS
                    - Handlebars
                    - Nunjucks

                We are using pug for template engines. Syntax is:
                    " npm install pug "

                    " app.set('view engine', 'pug'); "
                        // we will not import the pug module. It is built-in to express after the above line.
                    " app.set('views', './views'); " // this is optional/default. It is used to set the path of the views folder.
                    " app.get('/', (req, res) => {
                        res.render('index', { title: 'My Express App', message: 'Hello' });
                    }); "
                    render is a function that is used to render the pug file. It takes two parameters:
                        - The name of the pug file.
                        - The object that contains the data that is used to render the pug file.
                    we have to create a folder named 'views' in the root directory. In it, we have to create a file
                    named 'index.pug'. Syntax is:
                        " html
                            head
                                title= title
                            body
                                h1= message "
                   


            Sending Data to server:
                We can send data to server from frontend in three methods:
                    - Body:
                        In this method we send data in the body of the request. We can send data in the body of the
                        request in two ways:
                            - JSON:
                                In this method we send data in JSON format. We can send data in JSON format by using
                                " res.json() " method. This method is used to send JSON response. It takes one argument
                                which is the data that we want to send to the server. It is used to send data in JSON
                                format.

                                How to use res.json() method:
                                    - Create a file named "index.js" and write the following code in it.
                                        " const express = require('express');
                                        const app = express();

                                        app.use(express.json());

                                        app.post('/user', (req, res) => {
                                            console.log(req.body);
                                            res.json(req.body);
                                        });

                                        app.listen(3000, () => {
                                            console.log(`Server is running on port 3000`);
                                        }); "
                                    - Run the server by using " node index.js " command.
                                    - Open the browser and type " localhost:3000 " in the address bar.
                                    - Open the browser console and type the following code in it.
                                        " fetch('http://localhost:3000/user', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({
                                                name: 'John',
                                                age: 30
                                            })
                                        })
                                        .then(res => res.json())
                                        .then(data => console.log(data)); "

                            - URL:
                                In this method we send data in URL format. We can send data in URL format by using
                                " res.send() " method. This method is used to send string response. It takes one argument
                                which is the data that we want to send to the server. It is used to send data in URL
                                format.

                                How to use res.send() method:
                                    - Create a file named "index.js" and write the following code in it.
                                        " const express = require('express');
                                        const app = express();

                                        app.use(express.urlencoded({ extended: true }));

                                        app.post('/user', (req, res) => {
                                            console.log(req.body);
                                            res.send(req.body);
                                        });

                                        app.listen(3000, () => {
                                            console.log(`Server is running on port 3000`);
                                        }); "
                                    - Run the server by using " node index.js " command.
                    -Headers:
                        In this method we send data in the headers of the request. We can send data in the headers of the
                        request by using " res.set() " method. This method is used to set HTTP response header field.
                        It takes two arguments which are the name of the header and the value of the header. It is used
                        to send data in the headers of the request.

                        How to use res.set() method:
                            - Create a file named "index.js" and write the following code in it.
                                " const express = require('express');
                                const app = express();

                                app.post('/user', (req, res) => {
                                    console.log(req.headers);
                                    res.set('Content-Type', 'application/json');
                                    res.send(req.headers);
                                });

                                app.listen(3000, () => {
                                    console.log(`Server is running on port 3000`);
                                }); "
                            - Run the server by using " node index.js " command.
                    -Query:
                        In this method we send data in the query of the request. We can send data in the query of the
                        request by using " res.send() " method. This method is used to send string response. It takes
                        one argument which is the data that we want to send to the server. It is used to send data in
                        the query of the request.

                        How to use res.send() method:
                            - Create a file named "index.js" and write the following code in it.
                                " const express = require('express');
                                const app = express();

                                app.get('/user', (req, res) => {
                                    console.log(req.query);
                                    res.send(req.query);
                                });

                                app.listen(3000, () => {
                                    console.log(`Server is running on port 3000`);
                                }); "
                            - Run the server by using " node index.js " command.
                            - Open the browser and type " localhost:3000/user?name=John&age=30 " in the address bar.


            Routes:
                Routes are the endpoints of the application. It is the part of the application that is responsible
                for handling the requests from the frontend and sending the response to the frontend. It is also
                responsible for handling the requests from the frontend and sending the response to the frontend.

                How to create routes:
                    - Create a folder named "routes" and write the following code in a file in it.
                        " const express = require('express');
                        const user = express.Router();     // Or simply as: const userRoute = require('express').Router();

                        user.get('/user', (req, res) => {
                            res.send('Hello User!');
                        });
                        module.exports = user; "
                    - Import the route in the "index.js" file.
                        " const user = require('./routes/user'); "
                    - Use the route in the "index.js" file.
                        " app.use('/api', user); "


            Security:
                We have to take care of the security of our application. It is of three types:
                    -1 Frontend:
                        We have to take care of the security of the frontend of our application. It is of two types:
                            -1.1 Cross-Site Scripting (XSS):
                                Cross-Site Scripting (XSS) is a type of security vulnerability that allows an attacker
                                to inject malicious code into a web application.
                            -1.2 Cross-Site Request Forgery (CSRF):
                                Cross-Site Request Forgery (CSRF) is a type of security vulnerability that allows an
                                attacker to trick a user into performing an unwanted action on a web application.
                    -2 Backend/Api:
                        We have to take care of the security of the backend/api of our application. So we must validate the
                        data that we receive from the frontend. Because user can deactivate the javascript and hence frontend validation.
                        
                        Validation:
                            For validation we use " Joi " package. It is used to validate the data that we receive from the
                            frontend. Its Syntax is:
                                "npm i joi"
                                Then in the file where we want to validate the data we write the following code:
                                    " const Joi = require('joi');

                                    const schema = Joi.object({
                                        name: Joi.string().min(3).required(),
                                        age: Joi.number().min(18).required(),
                                        password: Joi.min(3).required(),
                                        email: Joi.email().required()
                                    });

                                    const result = schema.validate(req.body);

                                    if (result.error) {
                                        res.status(400).send(result.error.details[0].message);
                                        return;
                                    } "
                            We should write this validation code in a separate file and then import it in the file where we
                            want to validate the data. This is because we can use this validation code in multiple files.
                            We must export it like this:
                                " module.exports.userSchema = userSchema;
                                module.exports.userLoginSchema = userLoginSchema; "
                            And then import it like this:
                                " const { userSchema, userLoginSchema } = require('./validation/schemas'); "

                        Password security:
                            We should not store the password in the database in plain text. We should store it in the
                            database in the form of hash. For this we use " bcrypt " package. 
                            Hash:
                                Hash is technique of converting the plain text into a string of characters that cannot be
                                reversed. It is used to make the password more secure.
                            Salt: 
                                Salt is a random string of characters that is added to the password before hashing. It is
                                used to make the hash more secure.
                            It is one-way process and it cannot be reversed. It will take a supercomputer to reverse it in 
                            almost 100 years. So we compare the hash of the password that we receive from the frontend with
                            the hash of the password that is stored in the database. If both the hashes are same then the
                            password is correct. If both the hashes are not same then the password is incorrect.
                            Its Syntax is:
                                "npm i bcrypt"
                            Then in the file where we want to store the password in the database we write the following code:
                                    " const bcrypt = require('bcrypt');
                                    .
                                    .
                                    async....
                                    const salt = await bcrypt.genSalt(10);
                                    const hash = await bcrypt.hash(req.body.password, salt); 
                                    const valid = await bcrypt.compare(req.body.password, user.password); "
                            - genSalt() method is used to generate the salt. It takes one argument which is the number of
                            rounds. The higher the number of rounds the more secure the password will be. It is an
                            asynchronous function.
                            - hash() method is used to generate the hash. It takes two arguments which are the password
                            and the salt. It is an asynchronous function.
                            - compare() method is used to compare the hash of the password that we receive from the frontend
                            with the hash of the password that is stored in the database. It takes two arguments which are
                            the password and the hash of the password that is stored in the database. It is an asynchronous
                            function and returns a boolean value.

                    -3 Database:
                        We have to take care of the security of the database of our application.

            
            Authentication:
                Authentication is the process of verifying the identity of a user. It is a process of verifying the
                identity of a user by claiming who they are.
                We can register a user as: 
                    "const { error } = validate(req.body);
                    if (error) return res.status(400).send(error.details[0].message);

                    let user = await User.findOne({ email: req.body.email });
                    if (user) return res.status(400).send('User already registered.');

                    user = new User({
                        name: req.body.name,
                        email: req.body.email,
                        password: req.body.password
                    }); 
                    await user.save(); 
                    res.send(user); "
                    "             

                Using Lodash package:
                    Lodash is a package that provides utility functions for common programming tasks using the functional
                    programming paradigm. It is a modern JavaScript utility library delivering modularity, performance &
                    extras. It is based on the popular underscore.js library. It is used to simplify the code.
                    Its Syntax is:
                        "npm i lodash"
                    Then in the file where we want to use it we write the following code:
                        " const _ = require('lodash'); "
                    Then we can use the above code as:
                        "user = new User(_.pick(req.body, ['name', 'email', 'password']));
                        await user.save();
                        res.send(_.pick(user, ['_id', 'name', 'email']));"

                    We have other Lodash functions as:
                        - _.pick() method is used to pick the properties from an object. It takes two arguments which are
                        the object and the array of properties that we want to pick from the object.
                        - _.omit() method is used to omit the properties from an object. It takes two arguments which are
                        the object and the array of properties that we want to omit from the object.
                        - _.get() method is used to get the value of a property from an object. It takes two arguments
                        which are the object and the property that we want to get the value of.
                        - _.set() method is used to set the value of a property from an object. It takes three arguments
                        which are the object, the property that we want to set the value of and the value that we want to
                
                Using joi password complexity:
                    We can't store the password in the database in plain text. We should store it in the database in the form
                    of hash. For this we use " bcrypt " package. But first we should make it a strong password. For this we
                    use " joi-password-complexity " package. It is used to validate the password. It is used to make the
                    password strong. It is used to make the password more secure.
                    Its Syntax is:
                        "npm i joi-password-complexity"
                    Then in the file where we want to validate the password we write the following code:
                        " const Joi = require('joi');
                        const passwordComplexity = require('joi-password-complexity');

                        const schema = Joi.object({
                            name: Joi.string().min(3).required(),
                            age: Joi.number().min(18).required(),
                            password: passwordComplexity().required(),
                            email: Joi.email().required()
                        });

                        const result = schema.validate(req.body);

                        if (result.error) {
                            res.status(400).send(result.error.details[0].message);
                            return;
                        } "
                    We have the following options for the password:
                        - min: Minimum length of the password.
                        - max: Maximum length of the password.
                        - lowerCase: Minimum number of lowercase letters in the password.
                        - upperCase: Minimum number of uppercase letters in the password.
                        - numeric: Minimum number of numeric characters in the password.
                        - symbol: Minimum number of symbols in the password.
                        - requirementCount: Minimum number of requirements that must be met.
                        - custom: Custom validation function.
                        - message: Custom error message.
                    Can be used as:
                        " passwordComplexity({
                            min: 5,
                            max: 10,
                            lowerCase: 1,
                            upperCase: 1,
                            numeric: 1,
                            symbol: 1,
                            requirementCount: 4,
                        }); "

                    For bcrypt read the above section (Password Security).
                


            Authorization:
                Authorization is the process of verifying the permissions of a user. It is a process of verifying the
                permissions of a user by claiming what they can do.
                We can authorize a user by using JSON web token. It is a standard for representing claims securely
                between two parties. It is a compact and self-contained way of securely transmitting information between
                parties as a JSON object. It is used to authenticate a user. It is used to authorize a user. It is used to
                protect the routes of our application. It is used to protect the resources of our application.
                JsonWebToken has three parts:
                    - Header: It is a base64url encoded JSON object. It contains the type of the token which is JWT and
                    the hashing algorithm which is HMAC SHA256 or RSA.
                    - Payload: It is a base64url encoded JSON object. It contains the claims. It contains the data.
                    - Signature: It is a base64url encoded string. It is used to verify the token. It is used to verify
                    that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along
                    the way.

                    We should't store the token in the database. We should store it in the client side. We should store
                    it in the local storage of the browser. But if we want to store it in the database then we should
                    encrypt it. We should store it in the database in the form of hash.

                Its Syntax is:
                    "npm i jsonwebtoken"
                We can authorize a user as:
                In the file where we want to use it we write the following code:
                    " const jwt = require('jsonwebtoken'); "
                    "const {error} = validate(req.body);
                    if (error) return res.status(400).send(error.details[0].message);

                    let user = await User.findOne({ email: req.body.email });
                    if (!user) return res.status(400).send('Invalid email or password.');

                    const validPassword = await bcrypt.compare(req.body.password, user.password);
                    if (!validPassword) return res.status(400).send('Invalid email or password.');

                    const token = jwt.sign({ _id: user._id }, config.get('jwtPrivateKey'));
                    res.send(token);"
                Instead of sending a response we also include our token in the response header as:
                    "res.header('x-auth-token', token).send(_.pick(user, ['_id', 'name', 'email']));"
                
                Encapsulating Logic in mongoose model:
                    We see that we are writing the same code again and again. We can encapsulate the logic in mongoose
                    model (userModel), also import jwt. as:
                        "userSchema.methods.generateAuthToken = () => {
                            const token = jwt.sign({ _id: this._id }, config.get('jwtPrivateKey'));
                            return token;
                        }"
                    Then we can use it as:
                        "const token = user.generateAuthToken();"

                Authorization middleware:
                    We can use a middleware function to authorize a user. It is a function that has access to the request
                    object (req), the response object (res), and the next middleware function in the application’s
                    request-response cycle. The next middleware function is commonly denoted by a variable named next.
                    We can use it as:
                        "const jwt = require('jsonwebtoken');
                        module.exports = function (req, res, next) {
                            const token = req.header('x-auth-token');
                            if (!token) return res.status(401).send('Access denied. No token provided.');

                            try {
                                const decoded = jwt.verify(token, config.get('jwtPrivateKey'));
                                req.user = decoded;
                                next();
                            }
                            catch (ex) {
                                res.status(400).send('Invalid token.');
                            }
                        }"
                    Then we can protect our routes and use the above middleware as:
                        "router.post('/books', auth, async (req, res) => {
                            const { error } = validate(req.body);
                            if (error) return res.status(400).send(error.details[0].message);

                            let book = new Book({ name: req.body.name });
                            book = await book.save();

                            res.send(book);
                        });"
                    We should't protect all the routes. We should protect only the routes that we want to protect.
                    mostly the post, put and delete routes.

                Getting the current user: 
                    We can get the current user by using the above middleware. We should hide some data (as password, credit
                    card number, etc) from the user. We can do it by using the select method. We can use it as:
                        "router.get('/me', auth, async (req, res) => {
                            const user = await User.findById(req.user._id).select('-password');
                            res.send(user);
                        });"

                Loging out a user:
                    We can log out a user by deleting the token from the client side. We can do it by using the following
                    code:
                        "router.post('/logout', auth, async (req, res) => {
                            const user = await User.findById(req.user._id);
                            user.token = null;
                            await user.save();
                            res.send('Logged out successfully.');
                        });"

                Role based Authorization:
                    We can authorize a user by using the role based authorization. We can do it by using the following
                    code:
                        "router.delete('/books', [auth, admin], async (req, res) => {
                            const book = await Book.findByIdAndRemove(req.body.id);
                            if (!book) return res.status(404).send('The book with the given ID was not found.');

                            res.send(book);
                        });"
                    for admin middleware we can use the following code:
                        "module.exports = function (req, res, next) {
                            if (!req.user.isAdmin) return res.status(403).send('Access denied.');

                            next();
                        }"
            
            
            Handling and logging Errors:
                Our app is error free and working fine. But we can get an error like not connectin to mongo db. We should 
                send an error message to the client and log the error on the server.
                
                Handling Promise Rejection:
                    When we don't handle promise rejection then we get an "UnhandledPromiseRejectionWarning" error. We can
                    handle it by using the try catch block in await async and by using the .catch() method in promise.
                    We can use it as:
                        "try {
                            const book = await Book.findByIdAndRemove(req.body.id);
                            if (!book) return res.status(404).send('The book with the given ID was not found.');

                            res.send(book);
                        }
                        catch (ex) {
                            res.status(500).send('Something failed.');
                            // 500 - Internal Server Error
                        }"

                Express Error Middleware:
                    We can use an error middleware because we don't want to write the same code again and again. We can
                    use this middleware in the index.js file bellow all the routes. We can use it as:
                        "app.use(function (err, req, res, next) {
                            res.status(500).send('Something failed.');
                        });"
                    But for a better implementation we use this in another file and import it. We can use it as:
                        "module.exports = function (err, req, res, next) {
                            res.status(500).send('Something failed.');
                        };"
                    Then we can use it as:
                        "const error = require('./middleware/error');
                        // .... bellow all the routes
                        app.use(error);"

                    Now we can use this in a route as:
                        "route.get('/', async (req, res, next) => {
                            try {
                                const book = await Book.findByIdAndRemove(req.body.id);
                                if (!book) return res.status(404).send('The book with the given ID was not found.');

                                res.send(book);
                            }
                            catch (ex) {
                                next(ex);
                            }
                        }"

                Removing try catch blocks:
                    See we are writing try catch block again and again. We can remove it by using a function that will
                    wrap the async function. We can use it as:
                        "function asyncMiddleware(handler) {
                            return async (req, res, next) => {
                                try {
                                    await handler(req, res);
                                }
                                catch (ex) {
                                    next(ex);
                                }
                            };
                        }"
                    Then we can use it by wrapping the async function in the asyncMiddleware function and also removing the 
                    try, catch, next in the async function as:
                        "router.get('/', asyncMiddleware(async (req, res) => {
                            const book = await Book.findByIdAndRemove(req.body.id);
                            if (!book) return res.status(404).send('The book with the given ID was not found.');

                            res.send(book);
                        }));"

                    We must define the asyncMiddleware function in a separate file and import it in different routes as:
                        " module.exports = function() ....."
                    Then we can use it as:
                        "const asyncMiddleware = require('../middleware/async');"

                Express async errors:
                    We see that we are writing the same asyncMiddleware function again and again. To get rid of this we can
                    use an npm package "express-async-errors". We can install it by using the following command:
                        "npm i express-async-errors"
                    Then we can use it by using the following code in the index.js file. Remember we should only require It
                    once, don't need to store it in a variable. We can use it as:
                        "require('express-async-errors');"
                    If this is not working use the above asyncMiddleware functions in the routes.

                Logging Errors:
                    Logging errors mean that we can log the errors on the server side. We can use the "winston" npm package
                    for logging errors.
                    Transport:
                        Transport is a mechanism to send the log to a specific destination. We can use the following
                        transports:
                            1. Console
                            2. File
                            3. HTTP
                            4. MongoDB
                            5. Redis
                            6. AWS CloudWatch
                            7. Azure Application Insights
                            8. Loggly
                            9. Papertrail
                            10. Logentries
                            11. Splunk
                            12. Logstash
                            13. New Relic
                            14. Apache Kafka
                            15. Syslog
                            16. Slack
                            17. Log4js
                            18. DailyRotateFile
                            19. Memory
                            20. Stream
                            21. Webhook
                            22. Winston CloudWatch
                            23. Winston Graylog2
                            24. Winston Logstash
                            25. Winston MongoDB
                            26. Winston Papertrail
                            27. Winston Slack
                            28. Winston Syslog
                            29. Winston Transport
                    We can install it by using the following command:
                        "npm i winston"
                    Then we can use it by using the following code in the index.js file as:
                        "const winston = require('winston');
                        winston.add(new winston.transports.File({ filename: 'logfile.log' }));"
                    Then in the file where we have defined thr errorMiddleware.js we can use it as:
                        "const winston = require('winston');
                        winston.error(err.message, err);"
                    We have some logging levels:
                        1. error:
                            use it when we want to log an error.
                            "winston.error(err.message, err);"
                        2. warn
                            use it when we want to log a warning.
                            "winston.warn(err.message, err);"
                        3. info
                            use it when we want to log an information.
                            "winston.info(err.message, err);"
                        4. verbose
                            use it when we want to log a verbose information.
                            "winston.verbose(err.message, err);"
                        5. debug
                            use it when we want to log a debug information.
                            "winston.debug(err.message, err);"
                        6. silly
                            use it when we want to log a silly information.
                            "winston.silly(err.message, err);"

                    Logging to MongoDB:
                        We can use the "winston-mongodb" npm package to log the errors to the MongoDB database.
                        We can install it by using the following command:
                            "npm i winston-mongodb"
                        Then we can use it by using the following code in the index.js file as:
                            "require('winston-mongodb');
                            winston.add(new winston.transports.MongoDB({ db: 'mongodb://localhost/vidly' }));"
                        
                    Uncaught Exception:
                        Some errors are not caught by the express error middleware. For example if we have a syntax error
                        in the code. We can use the following code to catch these errors as:
                            "process.on('uncaughtException', (ex) => {
                                console.log('We got an uncaught exception.');
                                winston.error(ex.message, ex);
                                process.exit(1);
                            });"

                    Unhandled promise rejection:
                        Some errors are not caught by the express error middleware. For example if we create an unhandled error
                        as:
                            "const p = promise.reject(new Error('Something failed miserably!'));
                            p.then(() => console.log('Done'));"
                         We can use the following code to catch these errors as:
                            "process.on('unhandledRejection', (ex) => {
                                console.log('We got an unhandled rejection.');
                                winston.error(ex.message, ex);
                                process.exit(1);
                            });"


            Deployment:
                Deployment means that we are going to deploy our application to the production server. We can deploy our
                node application to the following servers:
                    1. Heroku:
                        Heroku is a cloud platform as a service supporting several programming languages. We can deploy our
                        node application to the Heroku server.
                    2. Azure:
                        Azure is a cloud computing service created by Microsoft for building, testing, deploying, and managing
                        applications and services through Microsoft-managed data centers. We can deploy our node application to
                        the Azure server.
                    3. AWS:
                        AWS is a cloud computing platform that offers a wide set of cloud services.
                    4. Digital Ocean:
                        Digital Ocean is a cloud platform that offers a wide set of cloud services like compute, storage, networking,
                        databases, analytics, etc.
                    5. Google Cloud:
                        Google Cloud is a cloud computing platform that offers a wide set of cloud services like compute, storage,
                        networking, databases, analytics, etc.
                    6. Linode
                    7. OpenShift
                    8. Rackspace
                    9. Render
                    10. Scalingo
                    11. Surge
                    12. Vercel
                    13. Zeit
                    14. Cloud Foundry
                    15. Cloud Run
                    16. Cloudflare Workers
                    17. Cloudflare Pages
                    18. Cloudflare Workers Sites
                    19. Cloudflare Workers KV

                Preparing the app for deployment:
                    Before deploying our application to the production server we need to do some changes in our application.
                    1. Install some packages:
                        1. Helmet:
                            Helmet helps you secure your Express apps by setting various HTTP headers. It's not a silver bullet,
                            but it can help!
                            We can install it by using the following command:
                                "npm i helmet"
                            Then we can use it by using the following code in the index.js file as:
                                "const helmet = require('helmet');
                                app.use(helmet());"
                        2. Compression:
                            Compression middleware for Node.js. Compresses responses for all request that traverse the middleware,
                            based on the given options.
                            We can install it by using the following command:
                                "npm i compression"
                            Then we can use it by using the following code in the index.js file as:
                                "const compression = require('compression');
                                app.use(compression());"

                        Simply:
                            Make a file "production.js" in startup folder and add the following code in it as:
                                "const helmet = require('helmet');
                                const compression = require('compression');

                                module.exports = function(app) {
                                    app.use(helmet());
                                    app.use(compression());
                                }"
                            Then in the index.js file we can use it as:
                                "if (app.get('env') === 'production') {
                                    require('./startup/production')(app);
                                }"

                    Selecting a platform for deployment,
                    Heroku:
                        1. First we need to create an account on the Heroku website.
                        2. Then we need to install the Heroku CLI from the following link:
                            https://devcenter.heroku.com/articles/heroku-cli
                            After this we can check the version of the Heroku CLI by using the following command:
                                "heroku --version"
                        3. Then we need to login to the Heroku CLI by using the following command:
                            "heroku login"
                            After this enter your email and password.
                            if this fails then we can create a proxy as:
                                "set HTTP_PROXY=http://proxy.example.com:8080"
                        4. In package.json file we need to add the following code in the scripts section as:
                            "scripts": {
                                "start": "node index.js",
                                "heroku-postbuild": "npm install --only=dev && npm run build"
                            }, 
                            "engines": {
                                "node": "12.16.1"
                            },"
                            
                        5. Adding the code to git repository:
                            1. First we need to initialize the git repository by using the following command:
                                "git init"
                            2. Then we need to add the files to the git repository by using the following command:
                                "git add ."
                            3. Then we need to commit the files to the git repository by using the following command:
                                "git commit -m "Initial commit"
                            4. Remember to add the .gitignore file to the project and add the following code in it as:
                                "node_modules/
                                config/keys.js
                                coverage/"

                    
                    